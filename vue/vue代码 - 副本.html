<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
/*

v-bind
	v-if  条件
	v-else   
	v-else-if     这3个之间都不要隔其他元素或内容
	v-show  css -> block
	v-hide  css -> none
	v-for   循环
	v-text  文本
	v-html  文本和结构
	v-on   事件
	v-model  双向绑定  通过视图改变数据  通过数据改变视图

	@click.stop  阻止冒泡
    @mousedown.prevent   阻止默认行为
    
    v-model="b"  在点击按钮选中的时候   数据中直接有一个b:false   
    而用model="b"  点击时候  不用做任何判断  直接判断数据  选中就true 不选中就false
    
    统计多个表单信息的时候
    在使用v-model的时候  里边放一个数组  并且  按钮绑定的是同一个arr  
    则选中之后 会将选中的数据填充到arr中  不选则为 空


    v-model中要传数据 数据中的对象或者数据中的变量 （数组中包对象，数组）
    v-model = "字符串" 报错
    v-model = "数据"
    v-model

    在select下拉框中，直接绑上v-model中  如果option中有value的内容  则优先走 v-model输出的值为value的值
    如果没有value的值的时候  会走option里边的 innerHTML的内容

    一般在请选择中加上 disabled 禁止选择

    而写过滤的时候
    数组为数组中包着对象的时候，直接赋值一个新的对象  可以使用filter
    用map的时候，过滤的时候 ，数组的个数没有变，虽然过滤出去了，但是还在用一个undefined占着一个位子
    
    computed:{}
    是vue专有的一个计算属性，当数据发生变化的时候，通过变化的数据，做另一件事情；
    只要使用，一开始就会执行一次，之后只要数据发生变化就执行


    watch(指定数据的监听器)
    当指定数据发生变化的时候触发 ，一开始是不触发的，当数据发生了变化的时候就触发

    只能监听一层  多层监听不到
    然后用对象来写   才能进行多层监听


    val 这个名字是  data中叫什么这里就的叫什么  要做的一一对应
    val要监听的数据名字

    函数：
    watch:{
        val(v,ov){ //v变化之后的值   ov变化之前的值
            localStorage.setItem('name',v)  //将这个值存到了  本地缓存中..
        }
    }
        
    监听一个数组
    对象：
    watch:{
        arr:{
            handler(v,ov){
                localStorage.setItem('data',JSON.stringify(v))
            },
            deep:true //深度监听
        }
    }



    组件化开发
        主要是把一个打的功能拆分成若干个小的功能，解决高耦合的问题，方便开发人员维护。

    component(组件) 数据传递
    
    Vue.component(组件的名称,对象)    必须放在根实例上边

    {
        props:[], //可以是数组也可以是对象
        template:`<div>aaaa</div>`,
        data,
        methods,
        computed

    }

    组件的名称  尽量不要使用驼峰命名
    小技巧：组件的名字 和引入的名字最好一样


    写多个标签的时候  需要一个div把它包起来（这个DIV只能有一个） 包起来之后  里边可以放多个元素

    在写组件的时候  data必须是一个函数   
    return 出去的一个对象 对象下挂数据

    在写组件的时候  一般是数字还是字符串之类的  要进行判断  
    可以用props写成一个对象的格式  能更准确的判断你传入的东西是什么类型的
    如果不对应的类型  将给你抛出一个错误

    //第一种写法 简单明了  检测数据类型  并且 没有设置默认值
    props:{
        kw:Number,
        aa:String,
    }
    //这样的一种写法  给他设置了一个默认值  一般不传 会走这个默认的值
    props:{
        kw:{
            type:Number,//数据类型
            default:123 //没有就走默认
        }
    }


    双向数据绑定（数据和视图）

    单向数据流动（父级数据和子级数据的流动）

    数据从父级流向了子级,数据本身还是父级的，如果操作子级要改变父级的数据，
    只能通过子级告知父级，然后父级再进行改动数据





    */


</script> 
</body>
</html>