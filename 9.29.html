<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
/*

new 一元运算符（专门用来运算函数的）
+ 二元运算符
?:三目运算符
    new:
        使用new之后不用加括号一样会执行函数
        new完之后 this变为实例化对象
        默认的返回值不是undefined而是实例化对象
        写了ruturn，如果return后边是简单类型的，那么不会改变，她还是实例化对象
                   如果return后边是复合类型，那么返回结果是这个复合类型


块级作用域
    {}除了是对象还是块级作用域
    只要在块级作用域下声明变量（let）
    那么这个let变量是不会超出这个范围的

    如果声明一个函数，那么在块级之外访问这个函数为undefined，在内部就是函数本身

var:{
    在一个域中名字是可以重复的
    是不作用于块的
    会在window上挂一个属性
}

let:{
    在一个域中名字是不可以重复的
    是作用于块的
    有暂存死去，在声明的上边访问这个变量会报错
    在循环中  每次循环的值 都可以被块保存并使用
}

const:{
    值是不能改变的
    声明即赋值，不然会报错
    在一个域中名字是不可以重复的
    是作用于块的
    不会 在window上挂属性的
    有暂存死区，在声明的上面访问这个变量会报错
}


单例模式：
    1，把描述同一个东西的不同属性归纳在一起，用对象的管理的模式；
    2，单例模式它限时了类的实例化次数只能一次，在实例不存在的情况下，可以通过一个
    方法创建一个类来实现创建类的新实例，如果实例已经存在，它会简单返回该对象的引用。
    3，单例不同于静态类（或对象），因为我们可以推迟它们的初始化（通常是因为它们）需要
    的参数信息在类定义时是无法获取得的，直到需要使用静态实例时，无需使用资源或者内存。
    4，单例的唯一实例能通过子类去扩展，使用者不用更改代码就能使用一个扩展的实例。
    5，单例将导致测试变困难，不利于单元测试。

何时使用单例：
    是否每个应用程序使用这个类的方式都完全相同？
    是否每个应用程序任何时候都只需要一个类的实例？
    使用者不需要知道该类是这应用程序的那个部分？
    当满足这三点，那就可以用单例，关键就在于类的使用方式都相同，并且不需要应用于上下文

高级单例模式
    在给命名空间赋值的时候，不要直接赋值一个对象，而是先执行匿名函数，形成一个
    私有作用域AA（不销毁栈内存）,在AA中创建一个堆内存，把堆内存地址赋值给命名空间

    这种模式的好处： 我们完全可以在AA中创造很多的内容（变量或者函数）,哪些需要供外边
    调取使用的，我们暴露到返回值的对象中（模块化实现的一种思想）

工厂模式：
    把实现相同功能的的代码进行 封装 ，以此来实现“批量生产”（后期想要实现这个功能，只需要执行这个函数就行了）
    高内聚低耦合 减少页面中的冗余代码，提高代码的重复使用率

何时使用工厂：
    当对象或组件设置非常复杂的时候
    当需要根据所在的不同环境轻松生成对象的不同实例时
    当处置很多共享相同属性的小型对象或组件时。
    对象的实例只需要满足一个约定 -鸭子类型
        鸭子类型： 当觉得一直鸟走起来像鸭子，游泳起来像鸭子，那么这只鸟便可以称为鸭子；我们并
                    不关心对象是什么类型的，到底是不是鸭子，只关心行为。
面向对象：

    工厂模式new完之后，this,代替了空对象。this就代替了原材料，给this身上加工，最后因为new之后默认的返回值是this，所以
    可以不用写return this


模块化开发：
    团队协作开发的时候，会把产品按照功能板块进行划分，每一个功能板块有专人负责开发
    把各个板块之间公用的部门进行提取封装，后期在想实现这些功能，直接的调取引用即可（模块封装）
    高内聚低耦合


this:{
    全局：window
    单纯的函数调用：window
    定时器中：window
    方法中：方法前面 . 前面的主是谁，this就是谁
    事件中：时间触发谁，this就是谁
    严格模式下：this是undefined
    构造函数 构造函数的原型下：this是实例化对象
    }

call(this,实参1，实参2....)
apply(this,数组)
bind(this,实参1，实参2....)

共同点：改变this指向
不同点：
    call apply会自动执行函数  
    bind返回值是一个函数体  不会自动执行函数 需要手动执行


面向对象
    JS\JAVA\PHP\C#\Ruby\Python\C++...
    谁来写

面向过程：
    C 
    想到哪里了写哪里

面向对象编程：
    需要我们掌握： “对象、类、实例”的概念
    对象：万物皆对象
    类：对象的具体细分（按照功能特点进行分类：大类、小类）
    实例：类中具体的一个事物（拿出类别中的具体一个实例进行进行研究，那么当前类别下的其它实例也具备这些特点和特征）

面向对象：
    把相同的代码提取出来归为一类，把公共的方法挂在原型上的一种编程思想

面向对象的三大特征：
    封装、继承、多态
    抽象、封装、继承

构造函数：创建对象的函数


原型：
    当创建一个函数的时候，函数自身会有一些属性和方法
    其中有一个属性叫prototype，它就是原型。


    prototype:就是一个函数中的属性；   值是对象
    原型好比css中的class是解决性能问题的

    如果说实例化对象没有这个方法或者属性；
    还会去构造函数的原型下去查找这个属性或者方法

    {}  ->new Object

    一般写面向对象是把属性挂在类下，把方法挂在构造函数的原型下；

函数的三种角色：
    函数：
        function fn(){
            整理功能的一个容器，主要是为了复用
        }
    
    类（构造函数）
        function Person(name){
            this.name = name;
            创建对象
        }

    实例化对象
        函数是由大Function构造的
        function(){}  -> new Function
        
*/



</script>
</body>
</html>