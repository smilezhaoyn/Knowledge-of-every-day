<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
        /*
        
        
        一个组件完整的生命周期包含实例化阶段、活动阶段、销毁阶段三个阶段

组件初始化（initialization）阶段
也就是代码中类的构造方法constructor()，APP继承了react Component这个基类，才能有render()、生命周期等方法可以使用

super(props)

1、用来调用基类的构造方法( constructor() )
2、将父组件的props注入给子组件
constructor()

用来做一些组件的初始化工作，
如定义this.state的初始内容
import React,{Component} from 'react';
class App extends Component{
    constructor(props){
        super(props)
    }
}
组件挂载（Mounting）阶段
只会执行一次

constructor

 -> 数据初始化
ComponentWillmount

在组件挂载到DOM前调用，且只会被调用一次
render

解析jsx

根据组件的props和state，
return一个React元素（描述组件，即UI）
不负责组件实际渲染工作
ComponentDidMount

 挂载成功，多用于数据请求
 
 组件挂载到DOM后调用，且只会被调用一次
组件的更新(update)阶段

updating 当数据改变的时候触发

componentWillReceiveProps(nextProps)

当父级的数据变化
此方法只调用于props引起的组件更新过程中
参数nextProps是父组件传给当前组件的新props
但父组件render方法的调用不能保证
重传给当前组件的props是有变化的
所以根据nextProps和this.props来查明重传的props
是否改变,以及如果改变了要执行啥
//比如根据新的props调用this.setState出发当前组件的重新render
shouldComponentUpdate(nextProps,nextState)

组件是否需要更新

此方法通过比较nextProps，nextState
以及当前组件的this.props，this.state
返回true，则当前组件将继续执行更新过程
返回false，则当前组件停止更新
//以此可用来减少组件的不必要渲染，优化组件性能。
PS:
就算componentWillReceiveProps()执行this.setState
更新了state，但在render前
（如shouldComponentUpdate，componentWillUpdate）
this.state依然指向更新前的state
不然nextState及当前组件的this.state的对比就一直是true了
componentWillUpdate(nextProps, nextState)

调用render方法前执行
render

重新调用
componentDidUpdate(prevProps, prevState)

组件更新后被调用
//可以操作组件更新的DOM
//prevProps和prevState这两个参数指的是组件更新前的props和state
卸载阶段unmounting
此阶段只有一个生命周期方法 componentWillUnmount

组件卸载时候调用
应用场景：
清除定时器、清除格式事件
清除componentDidMount中手动创建的DOM元素等
（以避免引起内存泄漏）
        
        
        */
        
        
    </script>
</body>
</html>