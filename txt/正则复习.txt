正则：
	*定义：正确的规则，是用来专门处理字符串
	*正则分为修饰符和元字符（量词元字符和特殊元字符）其中两个斜杠中都属于元字符，斜杠后面是属于修饰符。
	*简写：// (放的是规则，可以放不带引号的字符串，元字符，分组)
	*标准写法：new RegExp （第一个参数：可以放 //或者字符串。注意是字符串形式的元字符，需要转义。第二个参数：放修饰符）
	*普通元字符：在正则当中，字面量方式创建的，两个斜杠中，除了特殊元字符和量词元字符以外的字符，叫做普通元字符。
字符串的正则的方法：
	let str = 'fhiefiwghiwuefhuisfhyiwyerhvisuhfuie';
	str.match(/i/g)  //找到想要找的，并且返回一个数组。 ["i", "i", "i", "i", "i", "i", "i"]
	str.search(/i/g)  //就算是写了全局，也只能找一个i，并且是i所在的索引位置。
	str.split(/i/g)  //找到i截取掉，并且返回一个数组。["fh", "ef", "wgh", "wuefhu", "sfhy", "wyerhv", "suhfu", "e"]

. 在正则中匹配任意的字符，除了 \n （换行） \r（回车）

string.replace('' || 正则，'' || callback);  把第一个参数替换第二个参数
	callback($0,$1,$2,$3)
		$0是匹配到的每一个字符串
		$1是匹配到每个字符串的索引位置
		$2整个字符串
		$4undefined
	括号分组
		$0是匹配到的每一个字符串
		$1是第一个分组
		$2是第二个分组  .....以此类推，匹配完之后，再是索引位置，整个字符串，undefined

正则的方法：
	test:验证，效验创建的字符串，是否符合正确的规则，如果匹配则返回值是true,如果不匹配，则返回值是false.
	exec:捕获 =》捕获之前会先拿着正则匹配传入的字符串，如果匹配成功，就返回匹配的详细信息，如果不成功，则为null.

正则中常用的修饰符：
	i:ignoreCase  =>忽略大小写
	m:multiline  =>多行匹配
	g:global =>全局匹配
	y:全局匹配，匹配一次后，必须从剩余的第一个位置开始匹配。确保了匹配之间不会有漏掉的字符.

g,y修饰符
	g修饰符只要剩余位置中存在匹配就可，
	y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。y修饰符确保了匹配之间不会有漏掉的字符.

	例子：1
	var s = 'aaa_aa_a';
	var r1 = /a+/g;
	var r2 = /a+/y;

	r1.exec(s) // ["aaa"]  //从开始找，能找到aaa
	r2.exec(s) // ["aaa"]  //从第一个位置开始找能找到aaa

	r1.exec(s) // ["aa"]   //第二次调用，在剩余位置中能找到，所以是输出 aa
	r2.exec(s) // null     //从aaa后边的位置找，是一个 _ 不是a，所以是找不到，就为null
	例子：2
	var s = 'aaa_aa_a';

	var s1 = /a+_/g
	var s2 = /a+_/y

	s1.exec(s)
["aaa_", index: 0, input: "aaa_aa_a", groups: undefined]

	s1.exec(s)
["aa_", index: 4, input: "aaa_aa_a", groups: undefined]

	s1.exec(s)
null

	s2.exec(s)
["aaa_", index: 0, input: "aaa_aa_a", groups: undefined]

	s2.exec(s)
["aa_", index: 4, input: "aaa_aa_a", groups: undefined]

	s2.exec(s)
null

正则中常用的量词元字符：
	*：0个到多个
	+：1个到多个
	? ：0个或者一个 【有或者没有】
	{n}: 匹配到n个
	{n,}: 匹配到n到多个
	{n,m}:匹配到n个到m个
正则中常用的特殊元字符：
	\d:  匹配0-9之间的任意一个数字
	\D:  除了0-9之间的任意字符
	\w:  匹配数字，字母，下划线中任意一个字符。[0-9a-zA-Z_]
	\W:  除了数字，字符，下划线以外的任意字符
	\s:  匹配一个空白字符
	\S：除了空白字符以外的其他字符
	\b:  匹配一个边界符
	\B：匹配一个除了边界以外的其他字符
	\n：匹配一个换行符
	. 点：  除了换行（\n），回车（\r）以外的其他字符
	^:   匹配一个开始的符号
	$:   匹配一个结束的符号
	x|y: x或者y中的任意一个字符
	[xy]:x或者y中的任意一个字符
	[^xyz]:非，除了xyz其他的任意字符	
	[a-z]:范围，a-z中的任意一个字符
	():分组捕获，提高优先级，分组引用
	(?:) 取消分组捕获
	(?=)正向预查
	(?!)负向预查

范围：
	数字范围：[0-9]
	小写范围：[a-z]
	大写范围：[A-Z]
	小写大写范围：[a-zA-Z]
	中文的范围：\u4e00-\u9fa5

正则中的小括号：
	1，提高优先级
	2，分组捕获
	3，分组引用

正则的懒惰性：每一次捕获都只捕获一位；
解决正则懒惰下的方法：加一个量词元字符就可以了（g）

正则的贪婪性：每次捕获都全部捕获出来，是因为有量词元字符的存在。
解决正则贪婪性的方法：需要在量词元字符的后面加一个  ？  ，按照最少的输出


	// 返回正则表达式的正文  ES5
	/abc/ig.source
	// "abc"

	// ES6 的 flags 属性
	// 返回正则表达式的修饰符
	/abc/ig.flags
	// 'gi'

	匹配百分号之前的数字  /\d+(?=%)/

