什么是闭包？闭包的应用场景？
	什么是闭包？
	子函数调用父函数得变量或者参数，并且 子函数被外界引用，此时父函数形成闭包环境，这个时候，父函数得参数或者变量的值不会被垃圾回收机制回收。
	闭包的应用场景？
	1）私有变量不被外界所干扰。（互相不冲突）
	在多人开发的时候，在全局作用下，难免会遇到名字重复的情况
	解决：
		1）使用封闭空间 (function(){})()
		2）使用命名空间  把变量变为属性，函数变为方法

	2）储存父函数得参数或者变量
	封闭空间的缺点：外边想用内部运算结果，是不能直接访问得到的。
	解决封闭空间的缺点的办法是：return出去  挂在window上

	for(var i=0;i<5;i++){setTimeout(function(){console.log(i)})}   结果是5个5
	for(var i=0;i<5;i++){(function(i)setTimeout(function(){console.log(i)})(i)}   结果是0 1 2 3 4 

let和var的区别？
	let:				var:
	不会映射window  			会映射window
	没有预解析，有暂存死区		有预解析
	支持块作用域			不支持块作用域
	不能重名				能重名

什么是高级单例模式？什么是工厂模式?
	高级单例模式：功能更强大的单独实例模式，用一个匿名函数自执行返回一个对象，对象中可以选择暴露对外接口（方法或者属性）；
	工厂模式：把相同功能的代码进行归类封装，一次达到批量生产的目的（原料-加工-出厂）；返回的是一个对象
	高内聚低耦合，减少冗余代码。提高代码重复使用率。

什么是面向对象？
	面向对象：把具有相同特征的代码抽象出来，归为一类，把描述这个类的细节、功能挂在这个类的原型上的一种设计开发编程思想。
		（工厂模式new完之后，this代替了空白对象，代替了原材料，给this加工，最后默认返回值是this(可以不用写return this)）

function有哪三种角色？
	1）普通函数
	2）类（构造函数）
	3）实例化对象 new Function  (函数是由Function构造出来的)

new不new区别？
	new				不new
	不加括号也能执行			必须加括号
	this默认指向实例			this指向的是window
	return 复杂类型 = 复杂类型		return写啥是啥
	         简单类型 = 实例化对象
	默认return是实例化对象		默认return是undefined

new是一元运算符，只能运算函数

原型和原型链的关系：
	函数上自身带有原型和原型链，而对象身上只有原型链；
	原型：当创建函数的时候，函数自身带有的属性prototype；并且这个原型是解决性能的问题，实例上没有就回去构造函数的 原型下查找
	原型链：当创建一个对象的时候，自身带有的属性__proto__；实例上的原型链 === 构造函数的原型
		实例没有， -> 类中查看 -> 实例.__proto__ ->构造函数的原型 -> 构造函数原型的原型链 -> Object.prototype

this会出现在哪些地方？
	window: 函数名单纯的调用（除了箭头函数） 匿名函数自执行  定时器  箭头函数暴露在全局
	对象：点前面的是谁this是谁
	实例化对象：new完之后  this指向实例化对象
	undefined: 严格模式 'use strict'
	事件：触发之后，this为事件绑定元素
	父级：箭头函数
改变this方法有哪些？
	call() 第一个参数：改变this指向 第二个参数之后就是实参 自执行函数
	apply()第一个参数：改变this指向 第二个参数是一个数组  自执行函数
	bind第一个参数化：改变this指向 第二个参数之后就是实参 调用之后不会立即执行，而是返回一个改变this之后的函数，需要手动执行
	注意：如果第一个参数是null或者undefined;this指向的是window;
		严格模式下：写啥this就指向谁

如何进行数据劫持？
	不能枚举，不可修改，不可删除
	let obj = {
	num:2;
	}
	let n = 2;
	Object.defineProperty(obj,'name',{
	get(){
	n +=2
	return n;
	},
	set(){}
	})
	console.log(obj.num <5 && obj.num >5)




垃圾清理：标记法，计数法