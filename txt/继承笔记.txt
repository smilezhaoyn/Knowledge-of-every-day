什么是继承
子类继承父类的一些属性和方法【私有属性和方法，或者共有属性和方法】
获取或者操作父类的一些属性和方法

call继承
子类私有继承父类私有
子类call方法改变父类中的this，是吧父类当做一个普通函数，现在父类当中的this被改变成子类的实例，就相当于把父类上的全部私有属性和方法，复制了一份到子类的私有中
缺点：这样做的话父类的公有方法和子类的实例就没有关系了
这样的话：子类的实例也拥有父类的私有属性和方法
注意：如果父类私有属性和子类的私有属性重名的话，我们一基类为准

原型继承
子类的公有继承父类私有+公有属性
父类的私有+共有=>只有父类的实例才会拥有
这样做会导致子类的原型上的constructor丢失，需要手动赋值一个constructor指向子类
注意：我们要给子类的原型上扩展公有方法，必须等到继承完之后，在给添加才生效
弊端：我们给父类的私有属性添加多少，子类的公有属性就拥有多少，最好的方法是子类的私有继承父类的私有，子类的公有继承父类的公有，所以要学习寄生组合继承

寄生组合继承
子类私有继承父类私有，子类公有继承父类公有
Object.create=》吧参数当做公有属性和方法给当前这个函数的返回值
总结：
子类私有继承父类私有：通过call继承的方法，将父类中的私有属性赋值一份到子类的私有属性中
子类的公有继承父类的公有：我们可以通过Object.create这个方法，将父类的原型当做参数传入，返回值是一个空对象，将其赋值给子类的原型，这样子类的原型就可以通过__proto__原型链找到父类的原型
注意：
但是这样做导致子类的原型constructor丢失，而且之前添加的公共方法也会被清空，为了构造函数的完整，我们需要手动添加constructor，在继承之后给子类得原型扩展

es6中的继承
就是es5我们说的寄生组合继承，通过extend继承父类私有属性和公有属性，如果有添加constructor函数的话，我们必须添加super，不然会报错，super就属于call继承，可以通过super给父类传参。除此之外都是公有属性。子类的公有属性通过原型链__proto__可以找到父类的公有属性【constructor没有丢失】